)
)
theta_model$coefficients <- c(theta_model$coefficients, "theta" = theta_hat)
theta_model$df.residual <- theta_model$df.residual - 1
theta_model$profile_loglik <- profile_loglik
theta_model$aic <- DImodels:::AIC2(theta_model)
return(theta_model)
}
func_swiss <- test_functional_redundancy(data = Switzerland, y = "yield", prop = 4:7,
groups = c("G1", "G1", "G2", "G2"),
selection = "BICc",
estimate_theta = TRUE)
data
block
density
treat
extra_formula
DI(data = data, y = attr(obj, "y"), prop = attr(obj, "prop"), DImodel = "ID",
block = block, density = density, treat = treat,
ID = FG, extra_formula = extra_formula)
data_theta_FG
theta_hat
theta_grid
# Condition 1 beta_i = beta_j
# Condition 2 delta_ij = 0, i.e., within_FG interaction is 0
# Condition 3 delta_ik = delta_jk, i.e., between_FG interactions
test_functional_redundancy <- function(data, y, prop, groups,
block = NA, density = NA, treat = NA,
estimate_theta = FALSE, theta = 1,
extra_formula = ~0,
cond1 = TRUE, cond2 = TRUE,
cond3 = TRUE, cond4 = TRUE, complete_model = NULL,
selection = c("F-test", "AIC", "BIC", "AICc", "BICc")){
# Fit full pairwise model
# TODO account for situation when it might not be possible to fit FULL
density_val <- density
comp_model <- DI(data = data, y = y, prop = prop, # FG = groups,
block = block, density = density_val, treat = treat,
estimate_theta = estimate_theta, theta = theta,
extra_formula = extra_formula,
DImodel = "FULL") %>% suppressWarnings()
# Model fulfilling first condition, i.e. beta_i = beta_j
# Everything else is same as complete_model, simply edit the ID effects
cond1_mod <- DI(data = data, y = y, prop = prop,
block = block, density = density_val, treat = treat,
estimate_theta = estimate_theta, theta = theta,
extra_formula = extra_formula,
DImodel = "FULL", ID = groups) %>% suppressWarnings()
# Model additionally fulfilling second condition, i.e. where delta_ik = delta_jk
# Same as cond1_mod, but now we have FG interactions (both between and within)
cond2_mod <- DI(data = data, y = y, prop = prop,
block = block, density = density_val, treat = treat,
estimate_theta = estimate_theta, theta = theta,
extra_formula = extra_formula,
DImodel = "FG", ID = groups, FG = groups) %>% suppressWarnings()
# Model additionally fulfilling third condition, i.e. delta_ij = 0
# Same as cond2_mod, but now within FG interactions are 0 (only between FGs)
## Manually prepare FG interaction terms and add only with
FG_ints <- DI_data_FG(prop = prop, FG = groups, data = data)$FG
## Set within FG interactions to 0 by removing them
bfg_ints <- colnames(FG_ints)[!startsWith(colnames(FG_ints), "wfg")] %>%
paste0("FG_", .)
## Add FG terms to data
mod3_data <- cbind(data, FG_ints %>% `colnames<-`(paste0("FG_", colnames(.))))
## Append extra formula
extra_formula_more <- as.formula(paste0("~ ",
paste0(c(extra_formula[[length(extra_formula)]],
bfg_ints),
collapse = " + ")))
## Fit model with DImodel = "ID" and manually specify the interaction terms
cond3_mod <- DI(data = mod3_data, y = y, prop = prop, DImodel = "ID",
block = block, density = density, treat = treat,
ID = groups, extra_formula = extra_formula_more) %>% suppressWarnings()
if(isTRUE(estimate_theta)){
#browser()
cond3_mod <- quick_theta(obj = cond3_mod, FG = groups, FG_in_model = bfg_ints,
block = block, treat = treat, density = density,
extra_formula = extra_formula_more)
}
#browser()
mods_list <- list(cond3_mod, cond2_mod, cond1_mod, comp_model)
selected <- redundancy_table(mods_list, selection = selection,
descriptions = c(cond1, cond2, cond3, cond4))
return(selected)
}
AICc <- DImodels:::AICc
BICc <- DImodels:::BICc
prof_lik <- function(theta, obj, FG, FG_in_model, block, density, treat, extra_formula, prop, data){
# prop <- attr(obj, "prop")
# prop_cols <- obj$original_data[, prop]
# data_theta_FG <- data.frame(model.matrix(obj), check.names = FALSE)
# data_theta_FG[, attr(cond3_mod, "y")] <- obj$original_data[, attr(cond3_mod, "y")]
#
# # Add original props to calculate interactions
# data_theta_FG <- cbind(data_theta_FG, obj$data[, prop])
# Calculate new interactions for given value of theta
new_FG <- DI_data_FG(prop = prop, FG = FG, theta = theta,
data = data[, prop])$FG %>%
`colnames<-`(paste0("FG_", colnames(.)))
# Append updated FG columns in model matrix
data[, FG_in_model] <- new_FG[, FG_in_model]
theta_model <- suppressMessages(
suppressWarnings(
DI(data = data, y = attr(obj, "y"), prop = prop, DImodel = "ID",
block = block, density = density, treat = treat,
ID = FG, extra_formula = extra_formula)
)
)
n <- nrow(theta_model$data)
p <- length(theta_model$coef) + 1
mu_hat <- fitted(theta_model)
sigma_hat <- sqrt(sum(theta_model$residuals^2)/(theta_model$df.residual) * (n - p)/n)
llik <- sum(dnorm(theta_model$y, mu_hat, sigma_hat, log = TRUE))
return(llik)
}
quick_theta <- function(obj, FG, FG_in_model, block, density, treat, extra_formula, upper_boundary = 1.5){
# Get necessary info
prop <- attr(obj, "prop")
prop_cols <- obj$original_data[, prop]
data_theta_FG <- data.frame(model.matrix(obj), check.names = FALSE)
data_theta_FG[, attr(obj, "y")] <- obj$original_data[, attr(obj, "y")]
# Add original props to calculate interactions
data_theta_FG <- cbind(data_theta_FG, obj$data[, prop])
optimum <- optimize(prof_lik, interval = c(0.00001, upper_boundary),
maximum = TRUE, obj = obj, prop = prop,
FG = FG, FG_in_model = FG_in_model, data = data_theta_FG,
block = block, treat = treat, density = density,
extra_formula = extra_formula)
theta_hat <- optimum$maximum
theta_grid <- seq(0.00001, upper_boundary + 1, length = 100)
proflik_theta_vec <- Vectorize(prof_lik, "theta")
profile_loglik <- proflik_theta_vec(theta = theta_grid, obj = obj, prop = prop,
FG = FG, FG_in_model = FG_in_model,
data = data_theta_FG)
# Adding theta_hat in the profile likelihood grid used for searching in the CI.
# This will ensure that the CI is always calculated on the estimate of theta
profile_loglik = data.frame(prof = c(profile_loglik, optimum$objective),
grid = c(theta_grid, theta_hat))
profile_loglik <- profile_loglik[order(profile_loglik$grid),]
# Calculate new interactions for given value of theta
new_FG <- DI_data_FG(prop = prop, FG = FG, theta = theta_hat,
data = data_theta_FG[, prop])$FG %>%
`colnames<-`(paste0("FG_", colnames(.)))
# Append updated FG columns in model matrix
data_theta_FG[, FG_in_model] <- new_FG[, FG_in_model]
theta_model <- suppressMessages(
suppressWarnings(
DI(data = data_theta_FG, y = attr(obj, "y"), prop = attr(obj, "prop"), DImodel = "ID",
block = block, density = density, treat = treat,
ID = FG, extra_formula = extra_formula)
)
)
theta_model$coefficients <- c(theta_model$coefficients, "theta" = theta_hat)
theta_model$df.residual <- theta_model$df.residual - 1
theta_model$profile_loglik <- profile_loglik
theta_model$aic <- DImodels:::AIC2(theta_model)
return(theta_model)
}
redundancy_table <- function(model_list,
selection = c("F-test", "AIC", "BIC", "AICc", "BICc"),
descriptions = c(TRUE, TRUE, TRUE, TRUE),
print_tables = TRUE){
# Partial matching for selection metric
selection <- match.arg(selection)
# Hard coded descriptions for the models
desc <- c("Model with grouped ID effects (i.e., \U03B2i = \U03B2j), between FG interactions (i.e., \U03B4ik = \U03B4jk ) and within FG interactions set to 0 (i.e., \U03B4ij = 0)",
"Model with grouped ID effects (i.e., \U03B2i = \U03B2j) and between FG interactions (i.e., \U03B4ik = \U03B4jk )",
"Model with grouped ID effects (i.e., \U03B2i = \U03B2j) but all interactions",
"Full model")
final_table <- data.frame(selection = sapply(model_list, function(x) selection)) #,
#treat = "none", #sapply(model_list, function(x) attr(x, "treat")),
#theta = sapply(model_list, function(x) attr(x, "theta_flag")))
rnames <- paste0("Model ", 1:length(model_list))
# browser()
rownames(final_table) <- rnames
if(selection == "F-test"){
# Family lock change later if more families are added
Test <- "F" # Could also be Chisq for non-gaussian families
final_table$Description <-  desc[descriptions]
anovas <- eval(parse(text = paste("anova(",
paste("model_list[[", 1:length(model_list), "]]",
sep = "", collapse = ","),
",test ='", Test, "')", sep = "")
))
rownames(anovas) <- rnames
p_values <- anovas$`Pr(>F)` # Change to ChiSq if more families are added
p_less <- which(p_values < .05)
p_value_selected <- ifelse(length(p_less) == 0, 1, max(p_less))
selected <- rnames[p_value_selected]
if(isTRUE(print_tables)){
message("Selection using F-tests.\n")
print(final_table, right = FALSE)
cat("\n\n")
printCoefmat(anovas, na.print = "")
}
} else {
final_table[, selection] <- sapply(model_list, get(selection))
final_table$Description <-  desc[descriptions]
selected <- rnames[which.min(final_table[[selection]])]
if(isTRUE(print_tables)){
message(paste("Selection by ", selection, "\nWarning: DI Model with the lowest ",
selection, " will be selected, even if the difference is very small.\nPlease inspect other models to see differences in ",
selection,".\n\n", sep = ""))
#final_table <- final_table[, c(1, 4, 2, 3, 5)]
print(final_table, right = FALSE)
}
}
message(paste0("Selected model: ", final_table$Description[which(rnames == selected)]))
return(model_list[[which(rnames == selected)]])
}
data(sim4)
func_mod <- test_functional_redundancy(data = sim4, y = "response", prop = 3:8,
groups = c("G1", "G1", "G2", "G2", "G3", "G3"))
data("Switzerland")
func_swiss <- test_functional_redundancy(data = Switzerland, y = "yield", prop = 4:7,
groups = c("G1", "G1", "G2", "G2"))
func_swiss <- test_functional_redundancy(data = Switzerland, y = "yield", prop = 4:7,
groups = c("G1", "G1", "G2", "G2"),
selection = "BICc",
estimate_theta = TRUE)
data("sim3")
quick_theta <- function(obj, FG, FG_in_model, block, density, treat, extra_formula, upper_boundary = 1.5){
# Get necessary info
prop <- attr(obj, "prop")
prop_cols <- obj$original_data[, prop]
data_theta_FG <- data.frame(model.matrix(obj), check.names = FALSE)
data_theta_FG[, attr(obj, "y")] <- obj$original_data[, attr(obj, "y")]
# Add original props to calculate interactions
data_theta_FG <- cbind(data_theta_FG, obj$data[, prop])
optimum <- optimize(prof_lik, interval = c(0.00001, upper_boundary),
maximum = TRUE, obj = obj, prop = prop,
FG = FG, FG_in_model = FG_in_model, data = data_theta_FG,
block = block, treat = treat, density = density,
extra_formula = extra_formula)
theta_hat <- optimum$maximum
theta_grid <- seq(0.00001, upper_boundary + 1, length = 100)
proflik_theta_vec <- Vectorize(prof_lik, "theta")
profile_loglik <- proflik_theta_vec(theta = theta_grid, obj = obj, prop = prop,
FG = FG, FG_in_model = FG_in_model,
data = data_theta_FG)
# Adding theta_hat in the profile likelihood grid used for searching in the CI.
# This will ensure that the CI is always calculated on the estimate of theta
profile_loglik = data.frame(prof = c(profile_loglik, optimum$objective),
grid = c(theta_grid, theta_hat))
profile_loglik <- profile_loglik[order(profile_loglik$grid),]
# Calculate new interactions for given value of theta
new_FG <- DI_data_FG(prop = prop, FG = FG, theta = theta_hat,
data = data_theta_FG[, prop])$FG %>%
`colnames<-`(paste0("FG_", colnames(.)))
# Append updated FG columns in model matrix
data_theta_FG[, FG_in_model] <- new_FG[, FG_in_model]
theta_model <- #suppressMessages(
suppressWarnings(
DI(data = data_theta_FG, y = attr(obj, "y"), prop = attr(obj, "prop"), DImodel = "ID",
block = block, density = density, treat = treat,
ID = FG, extra_formula = extra_formula)
)
#)
theta_model$coefficients <- c(theta_model$coefficients, "theta" = theta_hat)
theta_model$df.residual <- theta_model$df.residual - 1
theta_model$profile_loglik <- profile_loglik
theta_model$aic <- DImodels:::AIC2(theta_model)
return(theta_model)
}
func_swiss <- test_functional_redundancy(data = Switzerland, y = "yield", prop = 4:7,
groups = c("G1", "G1", "G2", "G2"),
selection = "BICc",
estimate_theta = TRUE)
redundancy_table <- function(model_list,
selection = c("F-test", "AIC", "BIC", "AICc", "BICc"),
descriptions = c(TRUE, TRUE, TRUE, TRUE),
print_tables = TRUE){
# Partial matching for selection metric
selection <- match.arg(selection)
# Hard coded descriptions for the models
desc <- c("Model with grouped ID effects (i.e., \U03B2i = \U03B2j), between FG interactions (i.e., \U03B4ik = \U03B4jk ) and within FG interactions set to 0 (i.e., \U03B4ij = 0)",
"Model with grouped ID effects (i.e., \U03B2i = \U03B2j) and between FG interactions (i.e., \U03B4ik = \U03B4jk )",
"Model with grouped ID effects (i.e., \U03B2i = \U03B2j) but all interactions",
"Full model")
final_table <- data.frame(selection = sapply(model_list, function(x) selection)) #,
#treat = "none", #sapply(model_list, function(x) attr(x, "treat")),
#theta = sapply(model_list, function(x) attr(x, "theta_flag")))
rnames <- paste0("Model ", 1:length(model_list))
# browser()
rownames(final_table) <- rnames
if(isTRUE(print_tables)){
message("\nModel selection\n")
}
if(selection == "F-test"){
# Family lock change later if more families are added
Test <- "F" # Could also be Chisq for non-gaussian families
final_table$Description <-  desc[descriptions]
anovas <- eval(parse(text = paste("anova(",
paste("model_list[[", 1:length(model_list), "]]",
sep = "", collapse = ","),
",test ='", Test, "')", sep = "")
))
rownames(anovas) <- rnames
p_values <- anovas$`Pr(>F)` # Change to ChiSq if more families are added
p_less <- which(p_values < .05)
p_value_selected <- ifelse(length(p_less) == 0, 1, max(p_less))
selected <- rnames[p_value_selected]
if(isTRUE(print_tables)){
message("Selection using F-tests.\n")
print(final_table, right = FALSE)
cat("\n\n")
printCoefmat(anovas, na.print = "")
}
} else {
final_table[, selection] <- sapply(model_list, get(selection))
final_table$Description <-  desc[descriptions]
selected <- rnames[which.min(final_table[[selection]])]
if(isTRUE(print_tables)){
message(paste("Selection by ", selection, "\nWarning: DI Model with the lowest ",
selection, " will be selected, even if the difference is very small.\nPlease inspect other models to see differences in ",
selection,".\n\n", sep = ""))
#final_table <- final_table[, c(1, 4, 2, 3, 5)]
print(final_table, right = FALSE)
}
}
message(paste0("Selected model: ", final_table$Description[which(rnames == selected)]))
return(model_list[[which(rnames == selected)]])
}
func_mod <- test_functional_redundancy(data = sim4, y = "response", prop = 3:8,
groups = c("G1", "G1", "G2", "G2", "G3", "G3"))
func_swiss <- test_functional_redundancy(data = Switzerland, y = "yield", prop = 4:7,
groups = c("G1", "G1", "G2", "G2"))
func_swiss <- test_functional_redundancy(data = Switzerland, y = "yield", prop = 4:7,
groups = c("G1", "G1", "G2", "G2"),
selection = "BICc",
estimate_theta = TRUE)
quick_theta <- function(obj, FG, FG_in_model, block, density, treat, extra_formula, upper_boundary = 1.5){
# Get necessary info
prop <- attr(obj, "prop")
prop_cols <- obj$original_data[, prop]
data_theta_FG <- data.frame(model.matrix(obj), check.names = FALSE)
data_theta_FG[, attr(obj, "y")] <- obj$original_data[, attr(obj, "y")]
# Add original props to calculate interactions
data_theta_FG <- cbind(data_theta_FG, obj$data[, prop])
optimum <- optimize(prof_lik, interval = c(0.00001, upper_boundary),
maximum = TRUE, obj = obj, prop = prop,
FG = FG, FG_in_model = FG_in_model, data = data_theta_FG,
block = block, treat = treat, density = density,
extra_formula = extra_formula)
theta_hat <- optimum$maximum
theta_grid <- seq(0.00001, upper_boundary + 1, length = 100)
proflik_theta_vec <- Vectorize(prof_lik, "theta")
profile_loglik <- proflik_theta_vec(theta = theta_grid, obj = obj, prop = prop,
FG = FG, FG_in_model = FG_in_model,
data = data_theta_FG)
# Adding theta_hat in the profile likelihood grid used for searching in the CI.
# This will ensure that the CI is always calculated on the estimate of theta
profile_loglik = data.frame(prof = c(profile_loglik, optimum$objective),
grid = c(theta_grid, theta_hat))
profile_loglik <- profile_loglik[order(profile_loglik$grid),]
# Calculate new interactions for given value of theta
new_FG <- DI_data_FG(prop = prop, FG = FG, theta = theta_hat,
data = data_theta_FG[, prop])$FG %>%
`colnames<-`(paste0("FG_", colnames(.)))
# Append updated FG columns in model matrix
data_theta_FG[, FG_in_model] <- new_FG[, FG_in_model]
theta_model <- suppressMessages(
suppressWarnings(
DI(data = data_theta_FG, y = attr(obj, "y"), prop = attr(obj, "prop"), DImodel = "ID",
block = block, density = density, treat = treat,
ID = FG, extra_formula = extra_formula)
)
)
message("Theta estimate: ", theta_hat)
theta_model$coefficients <- c(theta_model$coefficients, "theta" = theta_hat)
theta_model$df.residual <- theta_model$df.residual - 1
theta_model$profile_loglik <- profile_loglik
theta_model$aic <- DImodels:::AIC2(theta_model)
return(theta_model)
}
func_swiss <- test_functional_redundancy(data = Switzerland, y = "yield", prop = 4:7,
groups = c("G1", "G1", "G2", "G2"),
selection = "BICc",
estimate_theta = TRUE)
quick_theta <- function(obj, FG, FG_in_model, block, density, treat, extra_formula, upper_boundary = 1.5){
# Get necessary info
prop <- attr(obj, "prop")
prop_cols <- obj$original_data[, prop]
data_theta_FG <- data.frame(model.matrix(obj), check.names = FALSE)
data_theta_FG[, attr(obj, "y")] <- obj$original_data[, attr(obj, "y")]
# Add original props to calculate interactions
data_theta_FG <- cbind(data_theta_FG, obj$data[, prop])
optimum <- optimize(prof_lik, interval = c(0.00001, upper_boundary),
maximum = TRUE, obj = obj, prop = prop,
FG = FG, FG_in_model = FG_in_model, data = data_theta_FG,
block = block, treat = treat, density = density,
extra_formula = extra_formula)
theta_hat <- optimum$maximum
theta_grid <- seq(0.00001, upper_boundary + 1, length = 100)
proflik_theta_vec <- Vectorize(prof_lik, "theta")
profile_loglik <- proflik_theta_vec(theta = theta_grid, obj = obj, prop = prop,
FG = FG, FG_in_model = FG_in_model,
data = data_theta_FG)
# Adding theta_hat in the profile likelihood grid used for searching in the CI.
# This will ensure that the CI is always calculated on the estimate of theta
profile_loglik = data.frame(prof = c(profile_loglik, optimum$objective),
grid = c(theta_grid, theta_hat))
profile_loglik <- profile_loglik[order(profile_loglik$grid),]
# Calculate new interactions for given value of theta
new_FG <- DI_data_FG(prop = prop, FG = FG, theta = theta_hat,
data = data_theta_FG[, prop])$FG %>%
`colnames<-`(paste0("FG_", colnames(.)))
# Append updated FG columns in model matrix
data_theta_FG[, FG_in_model] <- new_FG[, FG_in_model]
theta_model <- suppressMessages(
suppressWarnings(
DI(data = data_theta_FG, y = attr(obj, "y"), prop = attr(obj, "prop"), DImodel = "ID",
block = block, density = density, treat = treat,
ID = FG, extra_formula = extra_formula)
)
)
message("Theta estimate: ", round(theta_hat, 2))
theta_model$coefficients <- c(theta_model$coefficients, "theta" = theta_hat)
theta_model$df.residual <- theta_model$df.residual - 1
theta_model$profile_loglik <- profile_loglik
theta_model$aic <- DImodels:::AIC2(theta_model)
return(theta_model)
}
redundancy_table <- function(model_list,
selection = c("F-test", "AIC", "BIC", "AICc", "BICc"),
descriptions = c(TRUE, TRUE, TRUE, TRUE),
print_tables = TRUE){
# Partial matching for selection metric
selection <- match.arg(selection)
# Hard coded descriptions for the models
desc <- c("Model with grouped ID effects (i.e., \U03B2i = \U03B2j), between FG interactions (i.e., \U03B4ik = \U03B4jk ) and within FG interactions set to 0 (i.e., \U03B4ij = 0)",
"Model with grouped ID effects (i.e., \U03B2i = \U03B2j) and between FG interactions (i.e., \U03B4ik = \U03B4jk )",
"Model with grouped ID effects (i.e., \U03B2i = \U03B2j) but all interactions",
"Full model")
final_table <- data.frame(selection = sapply(model_list, function(x) selection)) #,
#treat = "none", #sapply(model_list, function(x) attr(x, "treat")),
#theta = sapply(model_list, function(x) attr(x, "theta_flag")))
rnames <- paste0("Model ", 1:length(model_list))
# browser()
rownames(final_table) <- rnames
if(isTRUE(print_tables)){
message("\nModel selection\n")
}
if(selection == "F-test"){
# Family lock change later if more families are added
Test <- "F" # Could also be Chisq for non-gaussian families
final_table$Description <-  desc[descriptions]
anovas <- eval(parse(text = paste("anova(",
paste("model_list[[", 1:length(model_list), "]]",
sep = "", collapse = ","),
",test ='", Test, "')", sep = "")
))
rownames(anovas) <- rnames
p_values <- anovas$`Pr(>F)` # Change to ChiSq if more families are added
p_less <- which(p_values < .05)
p_value_selected <- ifelse(length(p_less) == 0, 1, max(p_less))
selected <- rnames[p_value_selected]
if(isTRUE(print_tables)){
message("Selection using F-tests.\n")
print(final_table, right = FALSE)
cat("\n\n")
printCoefmat(anovas, na.print = "")
}
} else {
final_table[, selection] <- sapply(model_list, get(selection))
final_table$Description <-  desc[descriptions]
selected <- rnames[which.min(final_table[[selection]])]
if(isTRUE(print_tables)){
message(paste("Selection by ", selection, "\nWarning: DI Model with the lowest ",
selection, " will be selected, even if the difference is very small.\nPlease inspect other models to see differences in ",
selection,".\n\n", sep = ""))
#final_table <- final_table[, c(1, 4, 2, 3, 5)]
print(final_table, right = FALSE)
}
}
message(paste0("Selected model: ", final_table$Description[which(rnames == selected)]))
return(model_list[[which(rnames == selected)]])
}
func_swiss <- test_functional_redundancy(data = Switzerland, y = "yield", prop = 4:7,
groups = c("G1", "G1", "G2", "G2"),
selection = "BICc",
estimate_theta = TRUE)
func_3 <- test_functional_redundancy(data = sim3, y = "response", prop = 4:12,
groups = c("G1", "G1", "G1", "G1", "G1", "G2", "G2", "G3", "G3"))
func_3 <- test_functional_redundancy(data = sim3, y = "response", prop = 4:12, treat = "Treatment",
groups = c("G1", "G1", "G1", "G1", "G1", "G2", "G2", "G3", "G3"))
sim3
func_3 <- test_functional_redundancy(data = sim3, y = "response", prop = 4:12, treat = "treatment",
groups = c("G1", "G1", "G1", "G1", "G1", "G2", "G2", "G3", "G3"))
func_3
data(sim2)
mod_ID <- DI(y = "response", estimate_theta = TRUE, data = sim2,
prop = 3:6, DImodel = "ID", FG = c("G1", "G1", "G2", "G2"))
mod_AV <- DI(y = "response", estimate_theta = TRUE, data = sim2,
prop = 3:6, DImodel = "AV", FG = c("G1", "G1", "G2", "G2"))
mod_FG <- DI(y = "response", estimate_theta = TRUE, data = sim2,
prop = 3:6, DImodel = "FG", FG = c("G1", "G1", "G2", "G2"))
mod_ADD <- DI(y = "response", estimate_theta = TRUE, data = sim2,
prop = 3:6, DImodel = "ADD", FG = c("G1", "G1", "G2", "G2"))
mod_FULL <- DI(y = "response", estimate_theta = TRUE, data = sim2,
prop = 3:6, DImodel = "FULL", FG = c("G1", "G1", "G2", "G2"))
contrast_vars <- list("p1" = c(0.5, 0.5, -1),
"p2" = c(0.5,  -1,  0),
"p4" = c(-1,  0.5,  1))
contrast_matrix(mod_ID, contrast_vars)
data(sim4)
func_mod <- test_functional_redundancy(data = sim4, y = "response", prop = 3:8,
groups = c("G1", "G1", "G2", "G2", "G3", "G3"))
func_swiss <- test_functional_redundancy(data = Switzerland, y = "yield", prop = 4:7,
groups = c("G1", "G1", "G2", "G2"),
selection = "BICc",
estimate_theta = TRUE)
